@group(0) @binding(0)
var<uniform> camera: mat4x4f;

@group(0) @binding(1)
var<storage, read> lights: LightBuffer;

@group(0) @binding(2)
var shadow_sampler: sampler; 

@group(0) @binding(3)
var shadow_texture: texture_depth_2d;

@group(0) @binding(4)
var<uniform> shadow_view: mat4x4f;

struct VertexOut {
  @builtin(position) position : vec4f,
  @location(0) normal : vec3f,
  @location(1) world_pos: vec3f,
  @location(2) color : vec3f,
  @location(3) luminance: f32,
  @location(4) uv : vec2f,
}

struct Light {
  data1: vec4f,
  data2: vec4f
}

fn light_pos(l: Light) -> vec3f {
  return l.data1.xyz;
} 

fn light_dir(l: Light) -> vec3f {
  return l.data1.xyz;
}

fn light_type(l: Light) -> f32 {
  return l.data1.w;
}

fn light_luminance(l: Light) -> f32 {
  return l.data2.w;
}

fn light_color(l: Light) -> vec3f {
  return l.data2.xyz;
}

struct LightBuffer {
  count: u32,
  ambient_luminance: f32,
  lights: array<Light>
}

@vertex
fn vertex_main(@location(0) position: vec3f,
               @location(1) normal: vec3f,
               @location(2) color: vec4f) -> VertexOut
{
  var output : VertexOut;
  output.position = (camera * vec4f(position, 1));
  output.world_pos = position;
  output.normal = normal;
  output.color = color.xyz;
  output.luminance = color.w;
  output.uv = (output.position.xy / output.position.w) * vec2f(0.5, -0.5) + 0.5;
  return output;
}

@fragment
fn fragment_main(fragData: VertexOut) -> @location(0) vec4f
{
  return vec4f(fragData.color, 1);
  /*
  var color: vec3f = vec3f(0,0,0);
  let directional = dot(fragData.normal, vec3f(0, 1, 0));
  let ambient = 0.2;
  return vec4f(fragData.color * (directional + ambient), 1);


  for(var i: u32 = 0; i < lights.count; i++){
    let light = lights.lights[i];
    if(light_type(light) == 0){
      //point light
      let dir = normalize(fragData.world_pos - light_pos(light));
      let normal_dot = max(-dot(dir, fragData.normal),0);
      let intensity = normal_dot * light_luminance(light);
      color += light_color(light) * intensity;
    } else {
      //directional light
      let dir = light_dir(light);
      let normal_dot = max(-dot(dir, fragData.normal),0);
      let intensity = normal_dot * light_luminance(light);
      color += light_color(light) * intensity;
    }
  }
  let ambient = lights.ambient_luminance + fragData.luminance;
  color += ambient;
  return vec4f(color * fragData.color, 1);


  return vec4f(ambient * fragData.color,1);

  let shadow_pos = (shadow_view * vec4(fragData.world_pos, 1));
  let uv = (shadow_pos.xy / shadow_pos.w) * vec2f(0.5, -0.5) + 0.5;
  let shadow_depth = textureSample(shadow_texture, shadow_sampler, uv);
  let frag_depth = shadow_pos.z / shadow_pos.w;
  let diff = frag_depth - shadow_depth;
  if(diff > 0.001){
  }

  return vec4f(color * fragData.color, 1);
*/
}