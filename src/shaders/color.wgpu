@group(0) @binding(0)
var<uniform> camera: mat4x4f;

@group(0) @binding(1)
var tex_sampler: sampler; 

@group(1) @binding(2)
var diffuse_texture : texture_2d<f32>;

@group(1) @binding(3)
var opacity_texture : texture_2d<f32>;

override has_opacity: bool;

struct VertexOut {
  @builtin(position) position : vec4f,
  @location(0) normal : vec3f,
  @location(1) uv : vec2f,
}

@vertex
fn vertex_main(@location(0) position: vec3f,
               @location(1) normal: vec3f,
               @location(2) uv: vec2f) -> VertexOut
{
  var output : VertexOut;
  output.position = (camera * vec4f(position, 1));
  output.normal = normal;
  output.uv = vec2(uv.x, 1-uv.y);
  return output;
}

struct FragmentOut {
  @location(0) color: vec4f,
  @location(1) position: vec4f,
  @location(2) normal: vec4f,
};

@fragment
fn fragment_main(fragData: VertexOut) -> FragmentOut
{
  let color = textureSample(diffuse_texture, tex_sampler, fragData.uv);
  var opacity = color.w; 
  if(has_opacity){
    opacity = textureSample(opacity_texture, tex_sampler, fragData.uv).w;
  }
  if(opacity < 0.01){
    discard;
  }

  /*let directional_light = dot(fragData.normal, vec3(0.0,0.3,0.9))*0.5;
  let ambient_light = 0.5;
  let lighted_color = color * (directional_light + ambient_light);
*/
  var frag = FragmentOut();
  frag.color = vec4(color.xyz, opacity);
  frag.normal = vec4f(fragData.normal,0.0);
  frag.position = fragData.position;
  return frag;
}