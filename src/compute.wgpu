@group(0) @binding(0)
var<storage, read_write> output: array<vec4f>;

@group(0) @binding(1)
var<storage, read> scene: Scene;

@group(0) @binding(2)
var<uniform> camera: mat4x4f;

var<private> rand_state: u32 = 421325123;
struct Sphere {
  data: vec4f,
  color: vec4f,
}

fn sphere_pos(s: Sphere) -> vec3f {
  return s.data.xyz;
}

fn radius(s: Sphere) -> f32 {
  return s.data.w;
}

fn sphere_color(s: Sphere) -> vec4f {
  return s.color;
}

fn sphere_luminance(s: Sphere) -> f32 {
  return s.color.w;
}

struct Scene {
  sphere_count: u32,
  spheres: array<Sphere>,
}

fn randf32() -> f32 {
  let a:u32 = 1103515245;
  let c:u32 = 12345;
  rand_state = (a * rand_state + c);
  return f32(rand_state) / 4294967296;
}

fn intersect(hit: ptr<function, vec3f>, ray_pos: vec3f, ray_dir: vec3f, sphere: Sphere) -> bool {
  let dist = sphere_pos(sphere) - ray_pos;
  let forward_dist = dot(dist, ray_dir);
  if(forward_dist < 0){
    return false;
  }
  let d = sqrt(dot(dist, dist) - forward_dist * forward_dist);
  if(d > radius(sphere)){
    return false;
  }
  let in_sphere_dist = sqrt(radius(sphere) * radius(sphere) - d * d);
  let intersect0 = forward_dist - in_sphere_dist;
  let intersect = intersect0 * ray_dir + ray_pos;

  if(dot(*hit, ray_pos) < dot(intersect, ray_pos)){
    *hit = intersect0 * ray_dir + ray_pos;
    return true;
  }
  return false;
}

fn raycast(pos: vec3f, dir: vec3f) -> vec4f{
  var hit: vec3f = pos + dir * 10000;
  var light: f32 = 0;
  var color = vec4f(0,0.5,1,1);
  for(var i:u32 = 0; i < scene.sphere_count; i++) {
    if(intersect(&hit, pos, dir, scene.spheres[i])){
      let norm = normalize(hit - sphere_pos(scene.spheres[i]));
      let directional_light = dot(norm, vec3f(0,1,0));
      let ambient_light = 0.2;
      let light = directional_light + ambient_light;
      color = light * sphere_color(scene.spheres[i]);
    }
  }

  color.w = 1;

  return color;
}

fn color_at(uv: vec2f) -> vec4f {
  let intrinsic_ray_pos = vec4f(0,0,0,1);
  let intrinsic_ray_dir = vec4f(uv.x,uv.y,1,0);
  let ray_pos = (camera * intrinsic_ray_pos).xyz;
  let ray_dir = normalize((camera * intrinsic_ray_dir).xyz);

  let color = raycast(ray_pos, ray_dir);

  if(color.w == 1){
    return color;
  } else {
    return vec4f(uv.x, uv.y, 0, 1);
  }
}

@compute @workgroup_size(8,8)
fn main(
  @builtin(global_invocation_id)
  global_id : vec3u,

  @builtin(local_invocation_id)
  local_id : vec3u,
) {
  // Avoid accessing the buffer out of bounds
  if (global_id.x >= RES_X || global_id.y >= RES_Y) {
    return;
  }

  let x = -(f32(global_id.x) / RES_X - 0.5) * 2;
  let y = -(f32(global_id.y) / RES_Y - 0.5) * 2;

  let x_width = 1.0 / RES_X;
  let y_width = 1.0 / RES_Y;

  var rand_state: u32 = 213512350 + global_id.x * 1235121212 + global_id.y * 1235263851;

  var color: vec4f;
  
  const multisample = 4;

  let multisample_offset = array(vec2f(-0.9, 0.2), vec2f(0.3, 0.8), vec2f(0.85,-0.2), vec2f(-0.3, -0.9));
  for(var i = 0; i < multisample; i++){
    let sample = vec2f(x,y) + vec2f(x_width, y_width) * multisample_offset[i];
    color += color_at(sample);
  }

  color /= multisample;

  output[global_id.x + global_id.y * RES_X] = color;
}